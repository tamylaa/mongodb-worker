{
  "version": 3,
  "sources": ["../../../src/shared/clients/d1Client.js", "../../../src/worker/utils/response.js", "../../../src/worker/utils/token.js", "../../../src/worker/handlers/auth.js", "../../../src/worker/handlers/users.js", "../../../src/worker/handlers/health.js", "../../../src/worker/index.js"],
  "sourceRoot": "C:\\Users\\Admin\\Documents\\coding\\tamyla\\mongodb-worker\\.wrangler\\tmp\\deploy-p8EFnc",
  "sourcesContent": ["/**\n * D1 Database Client\n * Provides an interface for interacting with Cloudflare D1\n */\n\nimport { initializeDatabase } from '../../config/d1.config.js';\n\n// In-memory database for development\nlet devDb;\n\n// Reset the in-memory database (for testing)\nexport function resetDevDb() {\n  if (devDb) {\n    devDb.tables = {\n      users: new Map(),\n      magic_links: new Map()\n    };\n  }\n  return devDb;\n}\n\nexport class D1Client {\n  constructor(db) {\n    // Handle both direct D1 binding and development environment\n    if (db && typeof db.prepare === 'function') {\n      this.db = db;\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn('Running in development mode with in-memory database');\n      if (!devDb) {\n        // Initialize in-memory database\n        const tables = {\n          users: new Map(),\n          magic_links: new Map()\n        };\n        \n        // Store tables reference for external access in tests\n        devDb = { tables };\n        \n        const prepareStatement = (sql, params = []) => {\n          return {\n            bind: (...bindParams) => prepareStatement(sql, [...params, ...bindParams]),\n            all: async () => {\n              // Handle SELECT queries\n              if (sql.includes('FROM users')) {\n                return { results: Array.from(tables.users.values()) };\n              } else if (sql.includes('FROM magic_links')) {\n                return { results: Array.from(tables.magic_links.values()) };\n              }\n              return { results: [] };\n            },\n            run: async () => {\n              // Handle INSERT queries\n              if (sql.includes('INSERT INTO users')) {\n                const id = params[0];\n                const user = {\n                  id,\n                  email: params[1],\n                  name: params[2],\n                  isEmailVerified: false,\n                  createdAt: params[3],\n                  updatedAt: params[4]\n                };\n                tables.users.set(id, user);\n                return { success: true };\n              } \n              // Handle UPDATE queries\n              else if (sql.includes('UPDATE users') && sql.includes('SET')) {\n                const userId = params[params.length - 1]; // Last param is the user ID (from WHERE id = ?)\n                const user = tables.users.get(userId);\n                \n                if (user) {\n                  // Parse the SET clause to get the field names\n                  const setClause = sql.split('SET')[1].split('WHERE')[0].trim();\n                  const setFields = setClause.split(',').map(field => field.trim().split('=')[0].trim());\n                  \n                  // Update each field in the user object\n                  setFields.forEach((field, index) => {\n                    if (field !== 'updatedAt' && index < params.length - 1) { // Skip updatedAt and the ID param\n                      user[field] = params[index];\n                    }\n                  });\n                  \n                  // Always update the updatedAt field\n                  user.updatedAt = new Date().toISOString();\n                  \n                  // Save the updated user\n                  tables.users.set(userId, user);\n                  return { success: true };\n                }\n                return { success: false, error: 'User not found' };\n              }\n              // Handle magic links\n              else if (sql.includes('INSERT INTO magic_links')) {\n                const id = params[0];\n                const magicLink = {\n                  id,\n                  userId: params[1],\n                  token: params[2],\n                  expiresAt: params[3],\n                  used: false,\n                  usedAt: null,\n                  createdAt: params[4]\n                };\n                tables.magic_links.set(id, magicLink);\n                return { success: true };\n              }\n              return { success: true };\n            },\n            first: async () => {\n              // Handle SELECT ... LIMIT 1\n              if (sql.includes('FROM users') && (sql.includes('WHERE email = ?') || sql.includes('email = ?'))) {\n                const email = params[0];\n                return Array.from(tables.users.values()).find(u => u.email === email);\n              } else if (sql.includes('FROM users') && (sql.includes('WHERE id = ?') || sql.includes('id = ?'))) {\n                const id = params[0];\n                return tables.users.get(id);\n              } else if (sql.includes('FROM magic_links') && (sql.includes('WHERE token = ?') || sql.includes('token = ?'))) {\n                const token = params[0];\n                return Array.from(tables.magic_links.values()).find(ml => ml.token === token);\n              } else if (sql.includes('FROM magic_links') && (sql.includes('WHERE userId = ?') || sql.includes('userId = ?'))) {\n                const userId = params[0];\n                return Array.from(tables.magic_links.values()).find(ml => ml.userId === userId);\n              }\n              return null;\n            }\n          };\n        };\n        \n        devDb = {\n          prepare: (sql) => prepareStatement(sql),\n          batch: async (statements) => {\n            const results = [];\n            const context = { results: [] };\n            \n            for (let i = 0; i < statements.length; i++) {\n              const stmt = statements[i];\n              \n              try {\n                // Handle function statements (for dependent queries)\n                if (typeof stmt === 'function') {\n                  // Pass a proxy that tracks results\n                  const result = await stmt({\n                    ...context,\n                    get results() {\n                      return context.results;\n                    }\n                  });\n                  results.push(result);\n                  context.results = [...context.results, result];\n                  continue;\n                }\n                \n                // Handle prepared statements\n                if (stmt && typeof stmt === 'object' && 'sql' in stmt) {\n                  if (stmt.sql.includes('UPDATE magic_links') || \n                      (stmt.sql.includes('magic_links') && stmt.sql.includes('SET used'))) {\n                    // Handle magic link updates (e.g., marking as used)\n                    const token = stmt.params && stmt.params[0];\n                    const magicLink = token && Array.from(tables.magic_links.values())\n                      .find(ml => ml.token === token);\n                    \n                    if (magicLink) {\n                      magicLink.used = true;\n                      magicLink.usedAt = new Date().toISOString();\n                      const result = { success: true };\n                      results.push(result);\n                      context.results.push(result);\n                    } else {\n                      const error = { success: false, error: 'Magic link not found' };\n                      results.push(error);\n                      context.results.push(error);\n                    }\n                  } else if (stmt.sql.includes('INSERT INTO magic_links')) {\n                    // Handle magic link insertion\n                    const id = stmt.params && stmt.params[0];\n                    if (id) {\n                      const magicLink = {\n                        id,\n                        userId: stmt.params[1],\n                        token: stmt.params[2],\n                        expiresAt: stmt.params[3],\n                        used: false,\n                        usedAt: null,\n                        createdAt: stmt.params[4] || new Date().toISOString()\n                      };\n                      tables.magic_links.set(id, magicLink);\n                      const result = { success: true };\n                      results.push(result);\n                      context.results.push(result);\n                    } else {\n                      const error = { success: false, error: 'Missing required fields for magic link' };\n                      results.push(error);\n                      context.results.push(error);\n                    }\n                  } else if (stmt.sql.includes('INSERT INTO users')) {\n                    // Handle user insertion\n                    const id = stmt.params && stmt.params[0];\n                    if (id) {\n                      const user = {\n                        id,\n                        email: stmt.params[1],\n                        name: stmt.params[2],\n                        isEmailVerified: false,\n                        createdAt: stmt.params[3] || new Date().toISOString(),\n                        updatedAt: stmt.params[4] || new Date().toISOString()\n                      };\n                      tables.users.set(id, user);\n                      const result = { success: true };\n                      results.push(result);\n                      context.results.push(result);\n                    } else {\n                      const error = { success: false, error: 'Missing required fields for user' };\n                      results.push(error);\n                      context.results.push(error);\n                    }\n                  } else if (stmt.sql.includes('SELECT') && stmt.sql.includes('FROM users')) {\n                    // Handle user selection\n                    const param = stmt.params && stmt.params[0];\n                    let user;\n                    \n                    if (param) {\n                      if (stmt.sql.includes('id = ?')) {\n                        user = tables.users.get(param);\n                      } else if (stmt.sql.includes('email = ?')) {\n                        user = Array.from(tables.users.values()).find(u => u.email === param);\n                      }\n                    }\n                    \n                    const result = user ? { results: [user] } : { results: [] };\n                    results.push(result);\n                    context.results.push(result);\n                  } else {\n                    // For other statements, just return success\n                    const result = { success: true };\n                    results.push(result);\n                    context.results.push(result);\n                  }\n                } else {\n                  // For non-SQL statements, just return success\n                  const result = { success: true };\n                  results.push(result);\n                  context.results.push(result);\n                }\n              } catch (error) {\n                console.error('Error in batch operation:', error);\n                const errorResult = { error: error.message, success: false };\n                results.push(errorResult);\n                context.results.push(errorResult);\n              }\n            }\n            \n            return results;\n          }\n        };\n      }\n      this.db = devDb;\n    } else {\n      throw new Error('Invalid D1 database binding');\n    }\n  }\n\n  /**\n   * Initialize the database tables if they don't exist\n   */\n  async initialize() {\n    try {\n      if (process.env.NODE_ENV !== 'development') {\n        await initializeDatabase(this.db);\n      } else {\n        console.log('Skipping database initialization in development mode');\n      }\n    } catch (error) {\n      console.error('Error initializing database:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new user\n   * @param {Object} userData - The user data\n   * @returns {Promise<Object>} The created user\n   */\n  async createUser({ email, name = '' }) {\n    const id = crypto.randomUUID();\n    const now = new Date().toISOString();\n    \n    try {\n      const result = await this.db.prepare(\n        'INSERT INTO users (id, email, name, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?)'\n      ).bind(id, email, name, now, now).run();\n      \n      if (!result.success) {\n        if (result.error?.message?.includes('UNIQUE constraint failed')) {\n          throw new Error('User already exists');\n        }\n        throw new Error('Failed to create user');\n      }\n      \n      return { id, email, name, isEmailVerified: false, createdAt: now, updatedAt: now };\n    } catch (error) {\n      console.error('Error creating user:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Update an existing user\n   * @param {string} userId - The ID of the user to update\n   * @param {Object} updates - The fields to update\n   * @returns {Promise<Object>} The updated user\n   */\n  async updateUser(userId, updates) {\n    const now = new Date().toISOString();\n    const allowedUpdates = ['name', 'email', 'isEmailVerified', 'lastLogin'];\n    const validUpdates = {};\n    \n    // Filter out any invalid updates\n    Object.keys(updates).forEach(key => {\n      if (allowedUpdates.includes(key)) {\n        validUpdates[key] = updates[key];\n      }\n    });\n    \n    // If no valid updates, return the current user\n    if (Object.keys(validUpdates).length === 0) {\n      return this.findUserById(userId);\n    }\n    \n    try {\n      // Build the SET clause for the SQL query\n      const setClause = Object.keys(validUpdates)\n        .map((key, index) => `${key} = ?`)\n        .join(', ');\n      \n      // Add updatedAt to the updates\n      const values = [...Object.values(validUpdates), now, userId];\n      \n      // Execute the update\n      const result = await this.db.prepare(\n        `UPDATE users SET ${setClause}, updatedAt = ? WHERE id = ?`\n      ).bind(...values).run();\n      \n      if (!result.success) {\n        throw new Error('Failed to update user');\n      }\n      \n      // Return the updated user\n      const updatedUser = await this.findUserById(userId);\n      if (!updatedUser) {\n        throw new Error('Failed to fetch updated user');\n      }\n      \n      return updatedUser;\n    } catch (error) {\n      console.error('Error updating user:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find a user by email\n   * @param {string} email - The email address\n   * @returns {Promise<Object|null>} The user or null if not found\n   */\n  async findUserByEmail(email) {\n    try {\n      if (process.env.NODE_ENV === 'development') {\n        const result = await this.db.prepare(\n          'SELECT * FROM users WHERE email = ?'\n        ).bind(email).all();\n        return result.results && result.results.length > 0 ? result.results[0] : null;\n      } else {\n        const user = await this.db.prepare(\n          'SELECT * FROM users WHERE email = ?'\n        ).bind(email).first();\n        return user || null;\n      }\n    } catch (error) {\n      console.error('Error finding user by email:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find a user by ID\n   * @param {string} userId - The user ID\n   * @returns {Promise<Object|null>} The user or null if not found\n   */\n  async findUserById(userId) {\n    try {\n      if (process.env.NODE_ENV === 'development') {\n        const result = await this.db.prepare(\n          'SELECT * FROM users WHERE id = ?'\n        ).bind(userId).all();\n        return result.results && result.results.length > 0 ? result.results[0] : null;\n      } else {\n        const user = await this.db.prepare(\n          'SELECT * FROM users WHERE id = ?'\n        ).bind(userId).first();\n        return user || null;\n      }\n    } catch (error) {\n      console.error('Error finding user by ID:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new magic link\n   * @param {Object} magicLinkData - The magic link data\n   * @returns {Promise<Object>} The created magic link\n   */\n  async createMagicLink({ userId, email, name }) {\n    const token = crypto.randomUUID();\n    const expiresAt = new Date(Date.now() + 15 * 60 * 1000).toISOString(); // 15 minutes\n    const now = new Date().toISOString();\n    \n    let user;\n    \n    // If we only have email, first try to get the user by email\n    if (!userId && email) {\n      user = await this.findUserByEmail(email);\n      \n      // If user doesn't exist, create a new one\n      if (!user) {\n        const newUserId = crypto.randomUUID();\n        await this.db.prepare(\n          'INSERT INTO users (id, email, name, isEmailVerified, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?)'\n        ).bind(\n          newUserId,\n          email,\n          name || null,\n          0, // isEmailVerified\n          now,\n          now\n        ).run();\n        \n        // Get the newly created user\n        user = await this.findUserByEmail(email);\n      }\n    } else if (userId) {\n      // If we have a userId, get the user by ID\n      user = await this.findUserById(userId);\n    } else {\n      throw new Error('Either userId or email must be provided');\n    }\n    \n    if (!user) {\n      throw new Error('Failed to find or create user');\n    }\n    \n    // Insert the magic link\n    await this.db.prepare(\n      'INSERT INTO magic_links (id, userId, token, expiresAt, used, createdAt) VALUES (?, ?, ?, ?, 0, ?)'\n    ).bind(\n      crypto.randomUUID(),\n      user.id,\n      token,\n      expiresAt,\n      now\n    ).run();\n    \n    return {\n      userId: user.id,\n      token,\n      expiresAt,\n      user: user\n    };\n  }\n\n  /**\n   * Verify a magic link token\n   * @param {string} token - The magic link token\n   * @returns {Promise<Object>} The user data if verification is successful\n   */\n  async verifyMagicLink(token) {\n    const now = new Date().toISOString();\n    \n    try {\n      // First, find and mark the magic link as used\n      const magicLinkResult = await this.db.prepare(`\n        SELECT * FROM magic_links \n        WHERE token = ? AND used = 0 AND expiresAt > ?\n      `).bind(token, now).all();\n      \n      if (!magicLinkResult.results || !magicLinkResult.results.length) {\n        throw new Error('Invalid or expired token');\n      }\n      \n      const magicLink = magicLinkResult.results[0];\n      const userId = magicLink.userId;\n      \n      // Find the user first to ensure they exist\n      const user = await this.findUserById(userId);\n      if (!user) {\n        throw new Error('User not found');\n      }\n      \n      // Mark the magic link as used\n      await this.db.prepare(`\n        UPDATE magic_links \n        SET used = 1, usedAt = ? \n        WHERE id = ?\n      `).bind(now, magicLink.id).run();\n      \n      // Update user's last login and verification status\n      await this.db.prepare(`\n        UPDATE users \n        SET lastLogin = ?, updatedAt = ?, isEmailVerified = 1 \n        WHERE id = ?\n      `).bind(now, now, userId).run();\n      \n      // Return the updated user\n      return await this.findUserById(userId);\n    } catch (error) {\n      console.error('Error verifying magic link:', error);\n      throw error;\n    }\n  }\n}\n", "/**\n * Create a JSON response with the given data and status code\n * @param {*} data - The response data\n * @param {number} [status=200] - The HTTP status code\n * @param {Object} [headers={}] - Additional headers to include\n * @returns {Response} A Response object with JSON body\n */\nexport function jsonResponse(data, status = 200, headers = {}) {\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n  };\n\n  return new Response(\n    JSON.stringify(data, null, 2),\n    {\n      status,\n      headers: {\n        ...defaultHeaders,\n        ...headers\n      }\n    }\n  );\n}\n\n/**\n * Create an error response\n * @param {string} message - The error message\n * @param {number} [status=400] - The HTTP status code\n * @param {Object} [details={}] - Additional error details\n * @returns {Response} A Response object with error details\n */\nexport function errorResponse(message, status = 400, details = {}) {\n  return jsonResponse(\n    {\n      success: false,\n      error: message,\n      ...details\n    },\n    status\n  );\n}\n\n/**\n * Create a success response\n * @param {*} data - The response data\n * @param {number} [status=200] - The HTTP status code\n * @returns {Response} A Response object with success status and data\n */\nexport function successResponse(data, status = 200) {\n  return jsonResponse(\n    {\n      success: true,\n      data\n    },\n    status\n  );\n}\n\n/**\n * Create a not found response\n * @param {string} [message='Resource not found'] - The error message\n * @returns {Response} A 404 Response object\n */\nexport function notFoundResponse(message = 'Resource not found') {\n  return errorResponse(message, 404);\n}\n\n/**\n * Create an unauthorized response\n * @param {string} [message='Unauthorized'] - The error message\n * @returns {Response} A 401 Response object\n */\nexport function unauthorizedResponse(message = 'Unauthorized') {\n  return errorResponse(message, 401);\n}\n\n/**\n * Create a forbidden response\n * @param {string} [message='Forbidden'] - The error message\n * @returns {Response} A 403 Response object\n */\nexport function forbiddenResponse(message = 'Forbidden') {\n  return errorResponse(message, 403);\n}\n\n/**\n * Create a bad request response\n * @param {string} [message='Bad Request'] - The error message\n * @param {Object} [errors={}] - Validation errors or additional details\n * @returns {Response} A 400 Response object\n */\nexport function badRequestResponse(message = 'Bad Request', errors = {}) {\n  return errorResponse(\n    message,\n    400,\n    Object.keys(errors).length > 0 ? { errors } : {}\n  );\n}\n", "/**\n * Generate a JWT token using Web Crypto API\n * @param {Object} payload - The payload to include in the token\n * @param {string} secret - The secret key to sign the token with\n * @param {string} expiresIn - Token expiration time (e.g., '7d', '24h')\n * @returns {Promise<string>} The generated JWT token\n */\nexport async function generateToken(payload, secret, expiresIn = '7d') {\n  if (!secret) {\n    throw new Error('JWT_SECRET is not defined');\n  }\n\n  // Calculate expiration time\n  let expiresInMs = 7 * 24 * 60 * 60 * 1000; // Default to 7 days\n  \n  if (expiresIn) {\n    const value = parseInt(expiresIn);\n    if (expiresIn.endsWith('d')) {\n      expiresInMs = value * 24 * 60 * 60 * 1000; // days\n    } else if (expiresIn.endsWith('h')) {\n      expiresInMs = value * 60 * 60 * 1000; // hours\n    } else if (expiresIn.endsWith('m')) {\n      expiresInMs = value * 60 * 1000; // minutes\n    } else if (expiresIn.endsWith('s')) {\n      expiresInMs = value * 1000; // seconds\n    } else {\n      expiresInMs = value; // assume milliseconds\n    }\n  }\n\n  const header = {\n    alg: 'HS256', // HMAC-SHA256\n    typ: 'JWT'\n  };\n\n  const now = Math.floor(Date.now() / 1000);\n  const exp = Math.floor((Date.now() + expiresInMs) / 1000);\n  \n  const data = {\n    ...payload,\n    iat: now,\n    exp\n  };\n\n  // Base64Url encode\n  const base64UrlEncode = (obj) => {\n    const str = JSON.stringify(obj);\n    const encoder = new TextEncoder();\n    const data = encoder.encode(str);\n    return btoa(String.fromCharCode(...new Uint8Array(data)))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/, '');\n  };\n\n  const encodedHeader = base64UrlEncode(header);\n  const encodedData = base64UrlEncode(data);\n  \n  // Create HMAC signature using Web Crypto API\n  const encoder = new TextEncoder();\n  const keyData = encoder.encode(secret);\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    keyData,\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign']\n  );\n  \n  const signature = await crypto.subtle.sign(\n    'HMAC',\n    cryptoKey,\n    encoder.encode(`${encodedHeader}.${encodedData}`)\n  );\n  \n  // Convert ArrayBuffer to base64url\n  const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n\n  return `${encodedHeader}.${encodedData}.${signatureBase64}`;\n}\n\n/**\n * Verify a JWT token using Web Crypto API\n * @param {string} token - The JWT token to verify\n * @param {string} secret - The secret key to verify the token with\n * @returns {Promise<Object>} The decoded token payload if verification is successful\n * @throws {Error} If the token is invalid or expired\n */\nexport async function verifyToken(token, secret) {\n  if (!token) {\n    throw new Error('No token provided');\n  }\n\n  if (!secret) {\n    throw new Error('JWT_SECRET is not defined');\n  }\n\n  const [encodedHeader, encodedData, signature] = token.split('.');\n  \n  if (!encodedHeader || !encodedData || !signature) {\n    throw new Error('Invalid token format');\n  }\n\n  // Create HMAC signature using Web Crypto API\n  const encoder = new TextEncoder();\n  const keyData = encoder.encode(secret);\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    keyData,\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['verify']\n  );\n  \n  // Convert base64url to Uint8Array\n  const signatureBytes = new Uint8Array(\n    atob(signature.replace(/-/g, '+').replace(/_/g, '/'))\n      .split('')\n      .map(c => c.charCodeAt(0))\n  );\n  \n  // Verify the signature\n  const data = encoder.encode(`${encodedHeader}.${encodedData}`);\n  const isValid = await crypto.subtle.verify(\n    'HMAC',\n    cryptoKey,\n    signatureBytes,\n    data\n  );\n  \n  if (!isValid) {\n    throw new Error('Invalid token signature');\n  }\n\n  // Decode payload\n  const base64UrlDecode = (str) => {\n    // Add padding if needed\n    str = str.replace(/-/g, '+').replace(/_/g, '/');\n    while (str.length % 4) {\n      str += '=';\n    }\n    const binaryString = atob(str);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return JSON.parse(new TextDecoder().decode(bytes));\n  };\n\n  const payload = base64UrlDecode(encodedData);\n  \n  // Check expiration\n  const now = Math.floor(Date.now() / 1000);\n  if (payload.exp && payload.exp < now) {\n    throw new Error('Token expired');\n  }\n\n  return payload;\n}\n", "import { jsonResponse } from '../utils/response.js';\nimport { generateToken, verifyToken } from '../utils/token.js';\n\n/**\n * Handle authentication requests\n * @param {Request} request - The incoming request\n * @param {D1Client} d1Client - The D1 database client\n * @param {Object} env - The Cloudflare Workers environment\n * @returns {Promise<Response>} The authentication response\n */\nexport async function handleAuth(request, d1Client, env) {\n  const url = new URL(request.url);\n  const path = url.pathname.replace('/api/auth', '');\n\n  try {\n    // Handle different auth endpoints\n    if (path === '/magic-link' && request.method === 'POST') {\n      return await handleMagicLink(request, d1Client, env);\n    } else if (path === '/verify' && request.method === 'POST') {\n      return await handleVerifyMagicLink(request, d1Client, env);\n    } else if (path === '/me' && request.method === 'GET') {\n      return await handleGetCurrentUser(request, d1Client, env);\n    }\n\n    return jsonResponse({ error: 'Not Found' }, 404);\n  } catch (error) {\n    console.error('Auth error:', error);\n    return jsonResponse(\n      { error: 'Authentication failed', message: error.message },\n      error.statusCode || 500\n    );\n  }\n}\n\n/**\n * Handle magic link generation\n */\nasync function handleMagicLink(request, d1Client, env) {\n  const { email, name } = await request.json();\n  \n  if (!email) {\n    throw { statusCode: 400, message: 'Email is required' };\n  }\n\n  // Create or get user and generate magic link\n  const { token, expiresAt, user } = await d1Client.createMagicLink({ \n    email, \n    name \n  });\n\n  // In a real app, you would send the magic link via email\n  const magicLink = `${new URL(request.url).origin}/auth/verify?token=${token}`;\n  \n  // For development, return the magic link in the response\n  return jsonResponse({\n    success: true,\n    message: 'Magic link generated',\n    // In production, you wouldn't return the magic link\n    // but for development, it's helpful to see it\n    magicLink: process.env.NODE_ENV === 'development' ? magicLink : undefined,\n    expiresAt\n  });\n}\n\n/**\n * Handle magic link verification\n */\nasync function handleVerifyMagicLink(request, d1Client, env) {\n  const { token } = await request.json();\n  \n  if (!token) {\n    throw { statusCode: 400, message: 'Token is required' };\n  }\n\n  // Verify the magic link and get the user\n  const user = await d1Client.verifyMagicLink(token);\n  \n  // Generate JWT token\n  const authToken = await generateToken(\n    { userId: user.id, email: user.email },\n    env.JWT_SECRET,\n    '7d' // 7 days expiration\n  );\n\n  return jsonResponse({\n    success: true,\n    token: authToken,\n    user: {\n      id: user.id,\n      email: user.email,\n      name: user.name,\n      isEmailVerified: user.isEmailVerified\n    }\n  });\n}\n\n/**\n * Get current authenticated user\n */\nasync function handleGetCurrentUser(request, d1Client, env) {\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    throw { statusCode: 401, message: 'Unauthorized' };\n  }\n\n  const token = authHeader.split(' ')[1];\n  const decoded = await verifyToken(token, env.JWT_SECRET);\n  \n  const user = await d1Client.findUserById(decoded.userId);\n  if (!user) {\n    throw { statusCode: 404, message: 'User not found' };\n  }\n\n  return jsonResponse({\n    id: user.id,\n    email: user.email,\n    name: user.name,\n    isEmailVerified: user.isEmailVerified,\n    lastLogin: user.lastLogin\n  });\n}\n", "import { jsonResponse } from '../utils/response.js';\n\n/**\n * Handle user-related requests\n * @param {Request} request - The incoming request\n * @param {D1Client} d1Client - The D1 database client\n * @param {Object} env - The Cloudflare Workers environment\n * @returns {Promise<Response>} The user response\n */\nexport async function handleUsers(request, d1Client, env) {\n  const url = new URL(request.url);\n  const path = url.pathname.replace('/api/users', '');\n  const userId = path.split('/')[1]; // Extract user ID from path if present\n\n  try {\n    // Handle different user endpoints\n    if (request.method === 'GET') {\n      if (path === '' || path === '/') {\n        // List users (for admin purposes)\n        return await listUsers(d1Client);\n      } else if (userId) {\n        // Get specific user\n        return await getUser(userId, d1Client);\n      }\n    } else if (request.method === 'POST' && (path === '' || path === '/')) {\n      // Create new user\n      return await createUser(request, d1Client);\n    } else if (request.method === 'PUT' && userId) {\n      // Update user\n      return await updateUser(request, userId, d1Client);\n    } else if (request.method === 'DELETE' && userId) {\n      // Delete user\n      return await deleteUser(userId, d1Client);\n    }\n\n    return jsonResponse({ error: 'Not Found' }, 404);\n  } catch (error) {\n    console.error('User handler error:', error);\n    return jsonResponse(\n      { error: 'User operation failed', message: error.message },\n      error.statusCode || 500\n    );\n  }\n}\n\n/**\n * List all users (paginated)\n */\nasync function listUsers(d1Client) {\n  const users = await d1Client.db.prepare(\n    'SELECT id, email, name, isEmailVerified, lastLogin, createdAt, updatedAt FROM users ORDER BY createdAt DESC LIMIT 100'\n  ).all();\n  \n  return jsonResponse(users.results || []);\n}\n\n/**\n * Get a specific user by ID\n */\nasync function getUser(userId, d1Client) {\n  const user = await d1Client.findUserById(userId);\n  \n  if (!user) {\n    throw { statusCode: 404, message: 'User not found' };\n  }\n\n  // Don't return sensitive information\n  const { password, ...userData } = user;\n  return jsonResponse(userData);\n}\n\n/**\n * Create a new user\n */\nasync function createUser(request, d1Client) {\n  const { email, name, password } = await request.json();\n  \n  if (!email) {\n    throw { statusCode: 400, message: 'Email is required' };\n  }\n\n  // In a real app, you would hash the password before storing it\n  const user = await d1Client.createUser({ email, name });\n  \n  return jsonResponse(user, 201);\n}\n\n/**\n * Update an existing user\n */\nasync function updateUser(request, userId, d1Client) {\n  const updates = await request.json();\n  \n  if (!updates || Object.keys(updates).length === 0) {\n    throw { statusCode: 400, message: 'No updates provided' };\n  }\n  \n  try {\n    // Use the D1Client's updateUser method to handle the update\n    const updatedUser = await d1Client.updateUser(userId, updates);\n    \n    if (!updatedUser) {\n      throw { statusCode: 404, message: 'User not found' };\n    }\n    \n    // Remove sensitive information before returning\n    const { password, ...userData } = updatedUser;\n    \n    return jsonResponse(userData);\n  } catch (error) {\n    console.error('Error updating user:', error);\n    throw { statusCode: error.statusCode || 500, message: error.message };\n  }\n}\n\n/**\n * Delete a user\n */\nasync function deleteUser(userId, d1Client) {\n  // In a real app, you would soft delete the user\n  const result = await d1Client.db.prepare(\n    'DELETE FROM users WHERE id = ? RETURNING id'\n  ).bind(userId).run();\n  \n  if (!result.results.length) {\n    throw { statusCode: 404, message: 'User not found' };\n  }\n\n  return jsonResponse({ success: true, message: 'User deleted' });\n}\n", "/**\n * Health check handler\n * @param {D1Client} d1Client - The D1 database client\n * @returns {Promise<Response>} The health check response\n */\nexport async function handleHealth(d1Client, env) {\n  const status = {\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    environment: env.NODE_ENV || 'development',\n    services: {\n      database: 'ok'\n    }\n  };\n\n  try {\n    // Only attempt database health check if not in development mode\n    if (process.env.NODE_ENV !== 'development') {\n      try {\n        await d1Client.db.prepare('SELECT 1').run();\n      } catch (dbError) {\n        console.error('Database health check failed:', dbError);\n        status.status = 'degraded';\n        status.services.database = 'unavailable';\n        status.databaseError = dbError.message;\n      }\n    } else {\n      status.services.database = 'development (in-memory)';\n    }\n    \n    return new Response(\n      JSON.stringify(status, null, 2),\n      { \n        status: status.status === 'ok' ? 200 : 503, \n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache, no-store, must-revalidate'\n        } \n      }\n    );\n  } catch (error) {\n    console.error('Health check failed:', error);\n    return new Response(\n      JSON.stringify({ \n        status: 'error',\n        error: 'Health check failed',\n        message: error.message,\n        environment: process.env.NODE_ENV || 'development'\n      }, null, 2), \n      { \n        status: 500, \n        headers: { \n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache, no-store, must-revalidate'\n        } \n      }\n    );\n  }\n}\n", "import { D1Client } from '../shared/clients/d1Client.js';\nimport { handleAuth } from './handlers/auth.js';\nimport { handleUsers } from './handlers/users.js';\nimport { handleHealth } from './handlers/health.js';\n\n// Initialize D1 client\nlet d1Client;\n\n// Simple in-memory cache for development\nconst devCache = new Map();\n\n/**\n * Handle incoming HTTP requests\n * @param {Request} request - The incoming request\n * @param {Object} env - The Cloudflare Workers environment\n * @param {Object} ctx - The Cloudflare Workers context\n * @returns {Promise<Response>} The response to the request\n */\nexport default {\n  async fetch(request, env, ctx) {\n    try {\n      // Initialize D1 client if not already initialized\n      if (!d1Client) {\n        try {\n          // In development or if DB binding is not available, use in-memory\n          if (env.NODE_ENV !== 'production' || !env.DB) {\n            console.warn(`Running in ${env.NODE_ENV || 'development'} mode with ${env.DB ? 'D1 binding available' : 'no D1 binding'}`);\n            d1Client = new D1Client(env.DB || {});\n          } else {\n            // In production with DB binding, use the real D1 binding\n            d1Client = new D1Client(env.DB);\n          }\n          await d1Client.initialize();\n        } catch (error) {\n          console.error('Failed to initialize D1 client:', error);\n          return new Response(\n            JSON.stringify({ \n              success: false, \n              error: 'Database initialization failed',\n              message: error.message \n            }), \n            { \n              status: 500, \n              headers: { 'Content-Type': 'application/json' } \n            }\n          );\n        }\n      }\n\n      const url = new URL(request.url);\n      const path = url.pathname;\n\n      // Route requests to appropriate handlers\n      if (path.startsWith('/api/auth')) {\n        return handleAuth(request, d1Client, env);\n      } else if (path.startsWith('/api/users')) {\n        return handleUsers(request, d1Client, env);\n      } \n      // Handle health check endpoint\n      if (path === '/health') {\n        return handleHealth(d1Client, env);\n      }\n\n      // Return 404 for unknown routes\n      return new Response('Not Found', { status: 404 });\n    } catch (error) {\n      console.error('Error handling request:', error);\n      return new Response(\n        JSON.stringify({ \n          success: false, \n          error: 'Internal Server Error',\n          message: error.message \n        }), \n        { \n          status: 500, \n          headers: { 'Content-Type': 'application/json' } \n        }\n      );\n    }\n  },\n};\n"],
  "mappings": ";;;;AAQA,IAAI;AAaG,IAAM,WAAN,MAAe;AAAA,EArBtB,OAqBsB;AAAA;AAAA;AAAA,EACpB,YAAY,IAAI;AAEd,QAAI,MAAM,OAAO,GAAG,YAAY,YAAY;AAC1C,WAAK,KAAK;AAAA,IACZ,WAAW,MAAwC;AACjD,cAAQ,KAAK,qDAAqD;AAClE,UAAI,CAAC,OAAO;AAEV,cAAM,SAAS;AAAA,UACb,OAAO,oBAAI,IAAI;AAAA,UACf,aAAa,oBAAI,IAAI;AAAA,QACvB;AAGA,gBAAQ,EAAE,OAAO;AAEjB,cAAM,mBAAmB,wBAAC,KAAK,SAAS,CAAC,MAAM;AAC7C,iBAAO;AAAA,YACL,MAAM,2BAAI,eAAe,iBAAiB,KAAK,CAAC,GAAG,QAAQ,GAAG,UAAU,CAAC,GAAnE;AAAA,YACN,KAAK,mCAAY;AAEf,kBAAI,IAAI,SAAS,YAAY,GAAG;AAC9B,uBAAO,EAAE,SAAS,MAAM,KAAK,OAAO,MAAM,OAAO,CAAC,EAAE;AAAA,cACtD,WAAW,IAAI,SAAS,kBAAkB,GAAG;AAC3C,uBAAO,EAAE,SAAS,MAAM,KAAK,OAAO,YAAY,OAAO,CAAC,EAAE;AAAA,cAC5D;AACA,qBAAO,EAAE,SAAS,CAAC,EAAE;AAAA,YACvB,GARK;AAAA,YASL,KAAK,mCAAY;AAEf,kBAAI,IAAI,SAAS,mBAAmB,GAAG;AACrC,sBAAM,KAAK,OAAO,CAAC;AACnB,sBAAM,OAAO;AAAA,kBACX;AAAA,kBACA,OAAO,OAAO,CAAC;AAAA,kBACf,MAAM,OAAO,CAAC;AAAA,kBACd,iBAAiB;AAAA,kBACjB,WAAW,OAAO,CAAC;AAAA,kBACnB,WAAW,OAAO,CAAC;AAAA,gBACrB;AACA,uBAAO,MAAM,IAAI,IAAI,IAAI;AACzB,uBAAO,EAAE,SAAS,KAAK;AAAA,cACzB,WAES,IAAI,SAAS,cAAc,KAAK,IAAI,SAAS,KAAK,GAAG;AAC5D,sBAAM,SAAS,OAAO,OAAO,SAAS,CAAC;AACvC,sBAAM,OAAO,OAAO,MAAM,IAAI,MAAM;AAEpC,oBAAI,MAAM;AAER,wBAAM,YAAY,IAAI,MAAM,KAAK,EAAE,CAAC,EAAE,MAAM,OAAO,EAAE,CAAC,EAAE,KAAK;AAC7D,wBAAM,YAAY,UAAU,MAAM,GAAG,EAAE,IAAI,WAAS,MAAM,KAAK,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC;AAGrF,4BAAU,QAAQ,CAAC,OAAO,UAAU;AAClC,wBAAI,UAAU,eAAe,QAAQ,OAAO,SAAS,GAAG;AACtD,2BAAK,KAAK,IAAI,OAAO,KAAK;AAAA,oBAC5B;AAAA,kBACF,CAAC;AAGD,uBAAK,aAAY,oBAAI,KAAK,GAAE,YAAY;AAGxC,yBAAO,MAAM,IAAI,QAAQ,IAAI;AAC7B,yBAAO,EAAE,SAAS,KAAK;AAAA,gBACzB;AACA,uBAAO,EAAE,SAAS,OAAO,OAAO,iBAAiB;AAAA,cACnD,WAES,IAAI,SAAS,yBAAyB,GAAG;AAChD,sBAAM,KAAK,OAAO,CAAC;AACnB,sBAAM,YAAY;AAAA,kBAChB;AAAA,kBACA,QAAQ,OAAO,CAAC;AAAA,kBAChB,OAAO,OAAO,CAAC;AAAA,kBACf,WAAW,OAAO,CAAC;AAAA,kBACnB,MAAM;AAAA,kBACN,QAAQ;AAAA,kBACR,WAAW,OAAO,CAAC;AAAA,gBACrB;AACA,uBAAO,YAAY,IAAI,IAAI,SAAS;AACpC,uBAAO,EAAE,SAAS,KAAK;AAAA,cACzB;AACA,qBAAO,EAAE,SAAS,KAAK;AAAA,YACzB,GAzDK;AAAA,YA0DL,OAAO,mCAAY;AAEjB,kBAAI,IAAI,SAAS,YAAY,MAAM,IAAI,SAAS,iBAAiB,KAAK,IAAI,SAAS,WAAW,IAAI;AAChG,sBAAM,QAAQ,OAAO,CAAC;AACtB,uBAAO,MAAM,KAAK,OAAO,MAAM,OAAO,CAAC,EAAE,KAAK,OAAK,EAAE,UAAU,KAAK;AAAA,cACtE,WAAW,IAAI,SAAS,YAAY,MAAM,IAAI,SAAS,cAAc,KAAK,IAAI,SAAS,QAAQ,IAAI;AACjG,sBAAM,KAAK,OAAO,CAAC;AACnB,uBAAO,OAAO,MAAM,IAAI,EAAE;AAAA,cAC5B,WAAW,IAAI,SAAS,kBAAkB,MAAM,IAAI,SAAS,iBAAiB,KAAK,IAAI,SAAS,WAAW,IAAI;AAC7G,sBAAM,QAAQ,OAAO,CAAC;AACtB,uBAAO,MAAM,KAAK,OAAO,YAAY,OAAO,CAAC,EAAE,KAAK,QAAM,GAAG,UAAU,KAAK;AAAA,cAC9E,WAAW,IAAI,SAAS,kBAAkB,MAAM,IAAI,SAAS,kBAAkB,KAAK,IAAI,SAAS,YAAY,IAAI;AAC/G,sBAAM,SAAS,OAAO,CAAC;AACvB,uBAAO,MAAM,KAAK,OAAO,YAAY,OAAO,CAAC,EAAE,KAAK,QAAM,GAAG,WAAW,MAAM;AAAA,cAChF;AACA,qBAAO;AAAA,YACT,GAhBO;AAAA,UAiBT;AAAA,QACF,GAxFyB;AA0FzB,gBAAQ;AAAA,UACN,SAAS,wBAAC,QAAQ,iBAAiB,GAAG,GAA7B;AAAA,UACT,OAAO,8BAAO,eAAe;AAC3B,kBAAM,UAAU,CAAC;AACjB,kBAAM,UAAU,EAAE,SAAS,CAAC,EAAE;AAE9B,qBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,oBAAM,OAAO,WAAW,CAAC;AAEzB,kBAAI;AAEF,oBAAI,OAAO,SAAS,YAAY;AAE9B,wBAAM,SAAS,MAAM,KAAK;AAAA,oBACxB,GAAG;AAAA,oBACH,IAAI,UAAU;AACZ,6BAAO,QAAQ;AAAA,oBACjB;AAAA,kBACF,CAAC;AACD,0BAAQ,KAAK,MAAM;AACnB,0BAAQ,UAAU,CAAC,GAAG,QAAQ,SAAS,MAAM;AAC7C;AAAA,gBACF;AAGA,oBAAI,QAAQ,OAAO,SAAS,YAAY,SAAS,MAAM;AACrD,sBAAI,KAAK,IAAI,SAAS,oBAAoB,KACrC,KAAK,IAAI,SAAS,aAAa,KAAK,KAAK,IAAI,SAAS,UAAU,GAAI;AAEvE,0BAAM,QAAQ,KAAK,UAAU,KAAK,OAAO,CAAC;AAC1C,0BAAM,YAAY,SAAS,MAAM,KAAK,OAAO,YAAY,OAAO,CAAC,EAC9D,KAAK,QAAM,GAAG,UAAU,KAAK;AAEhC,wBAAI,WAAW;AACb,gCAAU,OAAO;AACjB,gCAAU,UAAS,oBAAI,KAAK,GAAE,YAAY;AAC1C,4BAAM,SAAS,EAAE,SAAS,KAAK;AAC/B,8BAAQ,KAAK,MAAM;AACnB,8BAAQ,QAAQ,KAAK,MAAM;AAAA,oBAC7B,OAAO;AACL,4BAAM,QAAQ,EAAE,SAAS,OAAO,OAAO,uBAAuB;AAC9D,8BAAQ,KAAK,KAAK;AAClB,8BAAQ,QAAQ,KAAK,KAAK;AAAA,oBAC5B;AAAA,kBACF,WAAW,KAAK,IAAI,SAAS,yBAAyB,GAAG;AAEvD,0BAAM,KAAK,KAAK,UAAU,KAAK,OAAO,CAAC;AACvC,wBAAI,IAAI;AACN,4BAAM,YAAY;AAAA,wBAChB;AAAA,wBACA,QAAQ,KAAK,OAAO,CAAC;AAAA,wBACrB,OAAO,KAAK,OAAO,CAAC;AAAA,wBACpB,WAAW,KAAK,OAAO,CAAC;AAAA,wBACxB,MAAM;AAAA,wBACN,QAAQ;AAAA,wBACR,WAAW,KAAK,OAAO,CAAC,MAAK,oBAAI,KAAK,GAAE,YAAY;AAAA,sBACtD;AACA,6BAAO,YAAY,IAAI,IAAI,SAAS;AACpC,4BAAM,SAAS,EAAE,SAAS,KAAK;AAC/B,8BAAQ,KAAK,MAAM;AACnB,8BAAQ,QAAQ,KAAK,MAAM;AAAA,oBAC7B,OAAO;AACL,4BAAM,QAAQ,EAAE,SAAS,OAAO,OAAO,yCAAyC;AAChF,8BAAQ,KAAK,KAAK;AAClB,8BAAQ,QAAQ,KAAK,KAAK;AAAA,oBAC5B;AAAA,kBACF,WAAW,KAAK,IAAI,SAAS,mBAAmB,GAAG;AAEjD,0BAAM,KAAK,KAAK,UAAU,KAAK,OAAO,CAAC;AACvC,wBAAI,IAAI;AACN,4BAAM,OAAO;AAAA,wBACX;AAAA,wBACA,OAAO,KAAK,OAAO,CAAC;AAAA,wBACpB,MAAM,KAAK,OAAO,CAAC;AAAA,wBACnB,iBAAiB;AAAA,wBACjB,WAAW,KAAK,OAAO,CAAC,MAAK,oBAAI,KAAK,GAAE,YAAY;AAAA,wBACpD,WAAW,KAAK,OAAO,CAAC,MAAK,oBAAI,KAAK,GAAE,YAAY;AAAA,sBACtD;AACA,6BAAO,MAAM,IAAI,IAAI,IAAI;AACzB,4BAAM,SAAS,EAAE,SAAS,KAAK;AAC/B,8BAAQ,KAAK,MAAM;AACnB,8BAAQ,QAAQ,KAAK,MAAM;AAAA,oBAC7B,OAAO;AACL,4BAAM,QAAQ,EAAE,SAAS,OAAO,OAAO,mCAAmC;AAC1E,8BAAQ,KAAK,KAAK;AAClB,8BAAQ,QAAQ,KAAK,KAAK;AAAA,oBAC5B;AAAA,kBACF,WAAW,KAAK,IAAI,SAAS,QAAQ,KAAK,KAAK,IAAI,SAAS,YAAY,GAAG;AAEzE,0BAAM,QAAQ,KAAK,UAAU,KAAK,OAAO,CAAC;AAC1C,wBAAI;AAEJ,wBAAI,OAAO;AACT,0BAAI,KAAK,IAAI,SAAS,QAAQ,GAAG;AAC/B,+BAAO,OAAO,MAAM,IAAI,KAAK;AAAA,sBAC/B,WAAW,KAAK,IAAI,SAAS,WAAW,GAAG;AACzC,+BAAO,MAAM,KAAK,OAAO,MAAM,OAAO,CAAC,EAAE,KAAK,OAAK,EAAE,UAAU,KAAK;AAAA,sBACtE;AAAA,oBACF;AAEA,0BAAM,SAAS,OAAO,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,EAAE;AAC1D,4BAAQ,KAAK,MAAM;AACnB,4BAAQ,QAAQ,KAAK,MAAM;AAAA,kBAC7B,OAAO;AAEL,0BAAM,SAAS,EAAE,SAAS,KAAK;AAC/B,4BAAQ,KAAK,MAAM;AACnB,4BAAQ,QAAQ,KAAK,MAAM;AAAA,kBAC7B;AAAA,gBACF,OAAO;AAEL,wBAAM,SAAS,EAAE,SAAS,KAAK;AAC/B,0BAAQ,KAAK,MAAM;AACnB,0BAAQ,QAAQ,KAAK,MAAM;AAAA,gBAC7B;AAAA,cACF,SAAS,OAAO;AACd,wBAAQ,MAAM,6BAA6B,KAAK;AAChD,sBAAM,cAAc,EAAE,OAAO,MAAM,SAAS,SAAS,MAAM;AAC3D,wBAAQ,KAAK,WAAW;AACxB,wBAAQ,QAAQ,KAAK,WAAW;AAAA,cAClC;AAAA,YACF;AAEA,mBAAO;AAAA,UACT,GA1HO;AAAA,QA2HT;AAAA,MACF;AACA,WAAK,KAAK;AAAA,IACZ,OAAO;AACL,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa;AACjB,QAAI;AACF,UAAI,OAAwC;AAC1C,cAAM,mBAAmB,KAAK,EAAE;AAAA,MAClC,OAAO;AACL,gBAAQ,IAAI,sDAAsD;AAAA,MACpE;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,gCAAgC,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,EAAE,OAAO,OAAO,GAAG,GAAG;AACrC,UAAM,KAAK,OAAO,WAAW;AAC7B,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AAEnC,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,GAAG;AAAA,QAC3B;AAAA,MACF,EAAE,KAAK,IAAI,OAAO,MAAM,KAAK,GAAG,EAAE,IAAI;AAEtC,UAAI,CAAC,OAAO,SAAS;AACnB,YAAI,OAAO,OAAO,SAAS,SAAS,0BAA0B,GAAG;AAC/D,gBAAM,IAAI,MAAM,qBAAqB;AAAA,QACvC;AACA,cAAM,IAAI,MAAM,uBAAuB;AAAA,MACzC;AAEA,aAAO,EAAE,IAAI,OAAO,MAAM,iBAAiB,OAAO,WAAW,KAAK,WAAW,IAAI;AAAA,IACnF,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,WAAW,QAAQ,SAAS;AAChC,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,UAAM,iBAAiB,CAAC,QAAQ,SAAS,mBAAmB,WAAW;AACvE,UAAM,eAAe,CAAC;AAGtB,WAAO,KAAK,OAAO,EAAE,QAAQ,SAAO;AAClC,UAAI,eAAe,SAAS,GAAG,GAAG;AAChC,qBAAa,GAAG,IAAI,QAAQ,GAAG;AAAA,MACjC;AAAA,IACF,CAAC;AAGD,QAAI,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AAC1C,aAAO,KAAK,aAAa,MAAM;AAAA,IACjC;AAEA,QAAI;AAEF,YAAM,YAAY,OAAO,KAAK,YAAY,EACvC,IAAI,CAAC,KAAK,UAAU,GAAG,GAAG,MAAM,EAChC,KAAK,IAAI;AAGZ,YAAM,SAAS,CAAC,GAAG,OAAO,OAAO,YAAY,GAAG,KAAK,MAAM;AAG3D,YAAM,SAAS,MAAM,KAAK,GAAG;AAAA,QAC3B,oBAAoB,SAAS;AAAA,MAC/B,EAAE,KAAK,GAAG,MAAM,EAAE,IAAI;AAEtB,UAAI,CAAC,OAAO,SAAS;AACnB,cAAM,IAAI,MAAM,uBAAuB;AAAA,MACzC;AAGA,YAAM,cAAc,MAAM,KAAK,aAAa,MAAM;AAClD,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,MAAM,8BAA8B;AAAA,MAChD;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,gBAAgB,OAAO;AAC3B,QAAI;AACF,UAAI,MAAwC;AAC1C,cAAM,SAAS,MAAM,KAAK,GAAG;AAAA,UAC3B;AAAA,QACF,EAAE,KAAK,KAAK,EAAE,IAAI;AAClB,eAAO,OAAO,WAAW,OAAO,QAAQ,SAAS,IAAI,OAAO,QAAQ,CAAC,IAAI;AAAA,MAC3E,OAAO;AACL,cAAM,OAAO,MAAM,KAAK,GAAG;AAAA,UACzB;AAAA,QACF,EAAE,KAAK,KAAK,EAAE,MAAM;AACpB,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,gCAAgC,KAAK;AACnD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,aAAa,QAAQ;AACzB,QAAI;AACF,UAAI,MAAwC;AAC1C,cAAM,SAAS,MAAM,KAAK,GAAG;AAAA,UAC3B;AAAA,QACF,EAAE,KAAK,MAAM,EAAE,IAAI;AACnB,eAAO,OAAO,WAAW,OAAO,QAAQ,SAAS,IAAI,OAAO,QAAQ,CAAC,IAAI;AAAA,MAC3E,OAAO;AACL,cAAM,OAAO,MAAM,KAAK,GAAG;AAAA,UACzB;AAAA,QACF,EAAE,KAAK,MAAM,EAAE,MAAM;AACrB,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK;AAChD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,gBAAgB,EAAE,QAAQ,OAAO,KAAK,GAAG;AAC7C,UAAM,QAAQ,OAAO,WAAW;AAChC,UAAM,YAAY,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,GAAI,EAAE,YAAY;AACpE,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AAEnC,QAAI;AAGJ,QAAI,CAAC,UAAU,OAAO;AACpB,aAAO,MAAM,KAAK,gBAAgB,KAAK;AAGvC,UAAI,CAAC,MAAM;AACT,cAAM,YAAY,OAAO,WAAW;AACpC,cAAM,KAAK,GAAG;AAAA,UACZ;AAAA,QACF,EAAE;AAAA,UACA;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,UACR;AAAA;AAAA,UACA;AAAA,UACA;AAAA,QACF,EAAE,IAAI;AAGN,eAAO,MAAM,KAAK,gBAAgB,KAAK;AAAA,MACzC;AAAA,IACF,WAAW,QAAQ;AAEjB,aAAO,MAAM,KAAK,aAAa,MAAM;AAAA,IACvC,OAAO;AACL,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAEA,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAGA,UAAM,KAAK,GAAG;AAAA,MACZ;AAAA,IACF,EAAE;AAAA,MACA,OAAO,WAAW;AAAA,MAClB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,IAAI;AAEN,WAAO;AAAA,MACL,QAAQ,KAAK;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,gBAAgB,OAAO;AAC3B,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AAEnC,QAAI;AAEF,YAAM,kBAAkB,MAAM,KAAK,GAAG,QAAQ;AAAA;AAAA;AAAA,OAG7C,EAAE,KAAK,OAAO,GAAG,EAAE,IAAI;AAExB,UAAI,CAAC,gBAAgB,WAAW,CAAC,gBAAgB,QAAQ,QAAQ;AAC/D,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC5C;AAEA,YAAM,YAAY,gBAAgB,QAAQ,CAAC;AAC3C,YAAM,SAAS,UAAU;AAGzB,YAAM,OAAO,MAAM,KAAK,aAAa,MAAM;AAC3C,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,gBAAgB;AAAA,MAClC;AAGA,YAAM,KAAK,GAAG,QAAQ;AAAA;AAAA;AAAA;AAAA,OAIrB,EAAE,KAAK,KAAK,UAAU,EAAE,EAAE,IAAI;AAG/B,YAAM,KAAK,GAAG,QAAQ;AAAA;AAAA;AAAA;AAAA,OAIrB,EAAE,KAAK,KAAK,KAAK,MAAM,EAAE,IAAI;AAG9B,aAAO,MAAM,KAAK,aAAa,MAAM;AAAA,IACvC,SAAS,OAAO;AACd,cAAQ,MAAM,+BAA+B,KAAK;AAClD,YAAM;AAAA,IACR;AAAA,EACF;AACF;;;AChgBO,SAAS,aAAa,MAAM,SAAS,KAAK,UAAU,CAAC,GAAG;AAC7D,QAAM,iBAAiB;AAAA,IACrB,gBAAgB;AAAA,IAChB,+BAA+B;AAAA,IAC/B,gCAAgC;AAAA,IAChC,gCAAgC;AAAA,EAClC;AAEA,SAAO,IAAI;AAAA,IACT,KAAK,UAAU,MAAM,MAAM,CAAC;AAAA,IAC5B;AAAA,MACE;AAAA,MACA,SAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF;AAAA,EACF;AACF;AAlBgB;;;ACAhB,eAAsB,cAAc,SAAS,QAAQ,YAAY,MAAM;AACrE,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAGA,MAAI,cAAc,IAAI,KAAK,KAAK,KAAK;AAErC,MAAI,WAAW;AACb,UAAM,QAAQ,SAAS,SAAS;AAChC,QAAI,UAAU,SAAS,GAAG,GAAG;AAC3B,oBAAc,QAAQ,KAAK,KAAK,KAAK;AAAA,IACvC,WAAW,UAAU,SAAS,GAAG,GAAG;AAClC,oBAAc,QAAQ,KAAK,KAAK;AAAA,IAClC,WAAW,UAAU,SAAS,GAAG,GAAG;AAClC,oBAAc,QAAQ,KAAK;AAAA,IAC7B,WAAW,UAAU,SAAS,GAAG,GAAG;AAClC,oBAAc,QAAQ;AAAA,IACxB,OAAO;AACL,oBAAc;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,SAAS;AAAA,IACb,KAAK;AAAA;AAAA,IACL,KAAK;AAAA,EACP;AAEA,QAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AACxC,QAAM,MAAM,KAAK,OAAO,KAAK,IAAI,IAAI,eAAe,GAAI;AAExD,QAAM,OAAO;AAAA,IACX,GAAG;AAAA,IACH,KAAK;AAAA,IACL;AAAA,EACF;AAGA,QAAM,kBAAkB,wBAAC,QAAQ;AAC/B,UAAM,MAAM,KAAK,UAAU,GAAG;AAC9B,UAAMA,WAAU,IAAI,YAAY;AAChC,UAAMC,QAAOD,SAAQ,OAAO,GAAG;AAC/B,WAAO,KAAK,OAAO,aAAa,GAAG,IAAI,WAAWC,KAAI,CAAC,CAAC,EACrD,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE;AAAA,EACtB,GARwB;AAUxB,QAAM,gBAAgB,gBAAgB,MAAM;AAC5C,QAAM,cAAc,gBAAgB,IAAI;AAGxC,QAAM,UAAU,IAAI,YAAY;AAChC,QAAM,UAAU,QAAQ,OAAO,MAAM;AACrC,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IACpC;AAAA,IACA;AAAA,IACA,EAAE,MAAM,QAAQ,MAAM,UAAU;AAAA,IAChC;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IACpC;AAAA,IACA;AAAA,IACA,QAAQ,OAAO,GAAG,aAAa,IAAI,WAAW,EAAE;AAAA,EAClD;AAGA,QAAM,kBAAkB,KAAK,OAAO,aAAa,GAAG,IAAI,WAAW,SAAS,CAAC,CAAC,EAC3E,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE;AAEpB,SAAO,GAAG,aAAa,IAAI,WAAW,IAAI,eAAe;AAC3D;AA3EsB;AAoFtB,eAAsB,YAAY,OAAO,QAAQ;AAC/C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAEA,QAAM,CAAC,eAAe,aAAa,SAAS,IAAI,MAAM,MAAM,GAAG;AAE/D,MAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,WAAW;AAChD,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACxC;AAGA,QAAM,UAAU,IAAI,YAAY;AAChC,QAAM,UAAU,QAAQ,OAAO,MAAM;AACrC,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IACpC;AAAA,IACA;AAAA,IACA,EAAE,MAAM,QAAQ,MAAM,UAAU;AAAA,IAChC;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AAGA,QAAM,iBAAiB,IAAI;AAAA,IACzB,KAAK,UAAU,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG,CAAC,EACjD,MAAM,EAAE,EACR,IAAI,OAAK,EAAE,WAAW,CAAC,CAAC;AAAA,EAC7B;AAGA,QAAM,OAAO,QAAQ,OAAO,GAAG,aAAa,IAAI,WAAW,EAAE;AAC7D,QAAM,UAAU,MAAM,OAAO,OAAO;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAGA,QAAM,kBAAkB,wBAAC,QAAQ;AAE/B,UAAM,IAAI,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG;AAC9C,WAAO,IAAI,SAAS,GAAG;AACrB,aAAO;AAAA,IACT;AACA,UAAM,eAAe,KAAK,GAAG;AAC7B,UAAM,QAAQ,IAAI,WAAW,aAAa,MAAM;AAChD,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,YAAM,CAAC,IAAI,aAAa,WAAW,CAAC;AAAA,IACtC;AACA,WAAO,KAAK,MAAM,IAAI,YAAY,EAAE,OAAO,KAAK,CAAC;AAAA,EACnD,GAZwB;AAcxB,QAAM,UAAU,gBAAgB,WAAW;AAG3C,QAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AACxC,MAAI,QAAQ,OAAO,QAAQ,MAAM,KAAK;AACpC,UAAM,IAAI,MAAM,eAAe;AAAA,EACjC;AAEA,SAAO;AACT;AAtEsB;;;ACjFtB,eAAsB,WAAW,SAASC,WAAU,KAAK;AACvD,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAM,OAAO,IAAI,SAAS,QAAQ,aAAa,EAAE;AAEjD,MAAI;AAEF,QAAI,SAAS,iBAAiB,QAAQ,WAAW,QAAQ;AACvD,aAAO,MAAM,gBAAgB,SAASA,WAAU,GAAG;AAAA,IACrD,WAAW,SAAS,aAAa,QAAQ,WAAW,QAAQ;AAC1D,aAAO,MAAM,sBAAsB,SAASA,WAAU,GAAG;AAAA,IAC3D,WAAW,SAAS,SAAS,QAAQ,WAAW,OAAO;AACrD,aAAO,MAAM,qBAAqB,SAASA,WAAU,GAAG;AAAA,IAC1D;AAEA,WAAO,aAAa,EAAE,OAAO,YAAY,GAAG,GAAG;AAAA,EACjD,SAAS,OAAO;AACd,YAAQ,MAAM,eAAe,KAAK;AAClC,WAAO;AAAA,MACL,EAAE,OAAO,yBAAyB,SAAS,MAAM,QAAQ;AAAA,MACzD,MAAM,cAAc;AAAA,IACtB;AAAA,EACF;AACF;AAtBsB;AA2BtB,eAAe,gBAAgB,SAASA,WAAU,KAAK;AACrD,QAAM,EAAE,OAAO,KAAK,IAAI,MAAM,QAAQ,KAAK;AAE3C,MAAI,CAAC,OAAO;AACV,UAAM,EAAE,YAAY,KAAK,SAAS,oBAAoB;AAAA,EACxD;AAGA,QAAM,EAAE,OAAO,WAAW,KAAK,IAAI,MAAMA,UAAS,gBAAgB;AAAA,IAChE;AAAA,IACA;AAAA,EACF,CAAC;AAGD,QAAM,YAAY,GAAG,IAAI,IAAI,QAAQ,GAAG,EAAE,MAAM,sBAAsB,KAAK;AAG3E,SAAO,aAAa;AAAA,IAClB,SAAS;AAAA,IACT,SAAS;AAAA;AAAA;AAAA,IAGT,WAAW,OAAyC,YAAY;AAAA,IAChE;AAAA,EACF,CAAC;AACH;AAzBe;AA8Bf,eAAe,sBAAsB,SAASA,WAAU,KAAK;AAC3D,QAAM,EAAE,MAAM,IAAI,MAAM,QAAQ,KAAK;AAErC,MAAI,CAAC,OAAO;AACV,UAAM,EAAE,YAAY,KAAK,SAAS,oBAAoB;AAAA,EACxD;AAGA,QAAM,OAAO,MAAMA,UAAS,gBAAgB,KAAK;AAGjD,QAAM,YAAY,MAAM;AAAA,IACtB,EAAE,QAAQ,KAAK,IAAI,OAAO,KAAK,MAAM;AAAA,IACrC,IAAI;AAAA,IACJ;AAAA;AAAA,EACF;AAEA,SAAO,aAAa;AAAA,IAClB,SAAS;AAAA,IACT,OAAO;AAAA,IACP,MAAM;AAAA,MACJ,IAAI,KAAK;AAAA,MACT,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,iBAAiB,KAAK;AAAA,IACxB;AAAA,EACF,CAAC;AACH;AA3Be;AAgCf,eAAe,qBAAqB,SAASA,WAAU,KAAK;AAC1D,QAAM,aAAa,QAAQ,QAAQ,IAAI,eAAe;AACtD,MAAI,CAAC,cAAc,CAAC,WAAW,WAAW,SAAS,GAAG;AACpD,UAAM,EAAE,YAAY,KAAK,SAAS,eAAe;AAAA,EACnD;AAEA,QAAM,QAAQ,WAAW,MAAM,GAAG,EAAE,CAAC;AACrC,QAAM,UAAU,MAAM,YAAY,OAAO,IAAI,UAAU;AAEvD,QAAM,OAAO,MAAMA,UAAS,aAAa,QAAQ,MAAM;AACvD,MAAI,CAAC,MAAM;AACT,UAAM,EAAE,YAAY,KAAK,SAAS,iBAAiB;AAAA,EACrD;AAEA,SAAO,aAAa;AAAA,IAClB,IAAI,KAAK;AAAA,IACT,OAAO,KAAK;AAAA,IACZ,MAAM,KAAK;AAAA,IACX,iBAAiB,KAAK;AAAA,IACtB,WAAW,KAAK;AAAA,EAClB,CAAC;AACH;AArBe;;;AC1Ff,eAAsB,YAAY,SAASC,WAAU,KAAK;AACxD,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAM,OAAO,IAAI,SAAS,QAAQ,cAAc,EAAE;AAClD,QAAM,SAAS,KAAK,MAAM,GAAG,EAAE,CAAC;AAEhC,MAAI;AAEF,QAAI,QAAQ,WAAW,OAAO;AAC5B,UAAI,SAAS,MAAM,SAAS,KAAK;AAE/B,eAAO,MAAM,UAAUA,SAAQ;AAAA,MACjC,WAAW,QAAQ;AAEjB,eAAO,MAAM,QAAQ,QAAQA,SAAQ;AAAA,MACvC;AAAA,IACF,WAAW,QAAQ,WAAW,WAAW,SAAS,MAAM,SAAS,MAAM;AAErE,aAAO,MAAM,WAAW,SAASA,SAAQ;AAAA,IAC3C,WAAW,QAAQ,WAAW,SAAS,QAAQ;AAE7C,aAAO,MAAM,WAAW,SAAS,QAAQA,SAAQ;AAAA,IACnD,WAAW,QAAQ,WAAW,YAAY,QAAQ;AAEhD,aAAO,MAAM,WAAW,QAAQA,SAAQ;AAAA,IAC1C;AAEA,WAAO,aAAa,EAAE,OAAO,YAAY,GAAG,GAAG;AAAA,EACjD,SAAS,OAAO;AACd,YAAQ,MAAM,uBAAuB,KAAK;AAC1C,WAAO;AAAA,MACL,EAAE,OAAO,yBAAyB,SAAS,MAAM,QAAQ;AAAA,MACzD,MAAM,cAAc;AAAA,IACtB;AAAA,EACF;AACF;AAlCsB;AAuCtB,eAAe,UAAUA,WAAU;AACjC,QAAM,QAAQ,MAAMA,UAAS,GAAG;AAAA,IAC9B;AAAA,EACF,EAAE,IAAI;AAEN,SAAO,aAAa,MAAM,WAAW,CAAC,CAAC;AACzC;AANe;AAWf,eAAe,QAAQ,QAAQA,WAAU;AACvC,QAAM,OAAO,MAAMA,UAAS,aAAa,MAAM;AAE/C,MAAI,CAAC,MAAM;AACT,UAAM,EAAE,YAAY,KAAK,SAAS,iBAAiB;AAAA,EACrD;AAGA,QAAM,EAAE,UAAU,GAAG,SAAS,IAAI;AAClC,SAAO,aAAa,QAAQ;AAC9B;AAVe;AAef,eAAe,WAAW,SAASA,WAAU;AAC3C,QAAM,EAAE,OAAO,MAAM,SAAS,IAAI,MAAM,QAAQ,KAAK;AAErD,MAAI,CAAC,OAAO;AACV,UAAM,EAAE,YAAY,KAAK,SAAS,oBAAoB;AAAA,EACxD;AAGA,QAAM,OAAO,MAAMA,UAAS,WAAW,EAAE,OAAO,KAAK,CAAC;AAEtD,SAAO,aAAa,MAAM,GAAG;AAC/B;AAXe;AAgBf,eAAe,WAAW,SAAS,QAAQA,WAAU;AACnD,QAAM,UAAU,MAAM,QAAQ,KAAK;AAEnC,MAAI,CAAC,WAAW,OAAO,KAAK,OAAO,EAAE,WAAW,GAAG;AACjD,UAAM,EAAE,YAAY,KAAK,SAAS,sBAAsB;AAAA,EAC1D;AAEA,MAAI;AAEF,UAAM,cAAc,MAAMA,UAAS,WAAW,QAAQ,OAAO;AAE7D,QAAI,CAAC,aAAa;AAChB,YAAM,EAAE,YAAY,KAAK,SAAS,iBAAiB;AAAA,IACrD;AAGA,UAAM,EAAE,UAAU,GAAG,SAAS,IAAI;AAElC,WAAO,aAAa,QAAQ;AAAA,EAC9B,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,UAAM,EAAE,YAAY,MAAM,cAAc,KAAK,SAAS,MAAM,QAAQ;AAAA,EACtE;AACF;AAvBe;AA4Bf,eAAe,WAAW,QAAQA,WAAU;AAE1C,QAAM,SAAS,MAAMA,UAAS,GAAG;AAAA,IAC/B;AAAA,EACF,EAAE,KAAK,MAAM,EAAE,IAAI;AAEnB,MAAI,CAAC,OAAO,QAAQ,QAAQ;AAC1B,UAAM,EAAE,YAAY,KAAK,SAAS,iBAAiB;AAAA,EACrD;AAEA,SAAO,aAAa,EAAE,SAAS,MAAM,SAAS,eAAe,CAAC;AAChE;AAXe;;;ACjHf,eAAsB,aAAaC,WAAU,KAAK;AAChD,QAAM,SAAS;AAAA,IACb,QAAQ;AAAA,IACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IAClC,aAAa,IAAI,YAAY;AAAA,IAC7B,UAAU;AAAA,MACR,UAAU;AAAA,IACZ;AAAA,EACF;AAEA,MAAI;AAEF,QAAI,OAAwC;AAC1C,UAAI;AACF,cAAMA,UAAS,GAAG,QAAQ,UAAU,EAAE,IAAI;AAAA,MAC5C,SAAS,SAAS;AAChB,gBAAQ,MAAM,iCAAiC,OAAO;AACtD,eAAO,SAAS;AAChB,eAAO,SAAS,WAAW;AAC3B,eAAO,gBAAgB,QAAQ;AAAA,MACjC;AAAA,IACF,OAAO;AACL,aAAO,SAAS,WAAW;AAAA,IAC7B;AAEA,WAAO,IAAI;AAAA,MACT,KAAK,UAAU,QAAQ,MAAM,CAAC;AAAA,MAC9B;AAAA,QACE,QAAQ,OAAO,WAAW,OAAO,MAAM;AAAA,QACvC,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,iBAAiB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,SAAS,MAAM;AAAA,QACf,aAAa;AAAA,MACf,GAAG,MAAM,CAAC;AAAA,MACV;AAAA,QACE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,UAChB,iBAAiB;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AArDsB;;;ACCtB,IAAI;AAYJ,IAAO,gBAAQ;AAAA,EACb,MAAM,MAAM,SAAS,KAAK,KAAK;AAC7B,QAAI;AAEF,UAAI,CAAC,UAAU;AACb,YAAI;AAEF,cAAI,IAAI,aAAa,gBAAgB,CAAC,IAAI,IAAI;AAC5C,oBAAQ,KAAK,cAAc,IAAI,YAAY,aAAa,cAAc,IAAI,KAAK,yBAAyB,eAAe,EAAE;AACzH,uBAAW,IAAI,SAAS,IAAI,MAAM,CAAC,CAAC;AAAA,UACtC,OAAO;AAEL,uBAAW,IAAI,SAAS,IAAI,EAAE;AAAA,UAChC;AACA,gBAAM,SAAS,WAAW;AAAA,QAC5B,SAAS,OAAO;AACd,kBAAQ,MAAM,mCAAmC,KAAK;AACtD,iBAAO,IAAI;AAAA,YACT,KAAK,UAAU;AAAA,cACb,SAAS;AAAA,cACT,OAAO;AAAA,cACP,SAAS,MAAM;AAAA,YACjB,CAAC;AAAA,YACD;AAAA,cACE,QAAQ;AAAA,cACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,YAChD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,YAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,YAAM,OAAO,IAAI;AAGjB,UAAI,KAAK,WAAW,WAAW,GAAG;AAChC,eAAO,WAAW,SAAS,UAAU,GAAG;AAAA,MAC1C,WAAW,KAAK,WAAW,YAAY,GAAG;AACxC,eAAO,YAAY,SAAS,UAAU,GAAG;AAAA,MAC3C;AAEA,UAAI,SAAS,WAAW;AACtB,eAAO,aAAa,UAAU,GAAG;AAAA,MACnC;AAGA,aAAO,IAAI,SAAS,aAAa,EAAE,QAAQ,IAAI,CAAC;AAAA,IAClD,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,SAAS;AAAA,UACT,OAAO;AAAA,UACP,SAAS,MAAM;AAAA,QACjB,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": ["encoder", "data", "d1Client", "d1Client", "d1Client"]
}
